<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Métodos Numéricos: Newton-Raphson y Bisección</title>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2c3e50;
            --accent-color: #e74c3c;
            --light-color: #ecf0f1;
            --dark-color: #34495e;
            --success-color: #2ecc71;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
            padding: 30px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }
        
        h1 {
            color: var(--secondary-color);
            margin-bottom: 10px;
        }
        
        h2 {
            color: var(--primary-color);
            margin: 25px 0 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        
        .description {
            color: var(--dark-color);
            margin-bottom: 20px;
        }
        
        .input-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: var(--dark-color);
        }
        
        input, select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: background-color 0.3s;
            margin-top: 10px;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        .results {
            margin-top: 30px;
        }
        
        .result-box {
            background-color: var(--light-color);
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .result-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--secondary-color);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        
        th, td {
            padding: 12px 15px;
            text-align: center;
            border: 1px solid #ddd;
        }
        
        th {
            background-color: var(--secondary-color);
            color: white;
        }
        
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        
        .error {
            color: var(--accent-color);
            font-weight: 600;
            margin-top: 10px;
        }
        
        .success {
            color: var(--success-color);
            font-weight: 600;
            margin-top: 10px;
        }
        
        .method-explanation {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
            border-left: 4px solid var(--primary-color);
        }
        
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
        }
        
        .tab.active {
            background-color: var(--primary-color);
            color: white;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @media (max-width: 768px) {
            .input-section {
                grid-template-columns: 1fr;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            .tab {
                margin-bottom: 5px;
                border-radius: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Métodos Numéricos para Cálculo de Raíces</h1>
            <p class="description">Aplicación que combina los métodos de Newton-Raphson y Bisección para aproximar raíces de funciones</p>
        </header>
        
        <div class="tabs">
            <div class="tab active" data-tab="input">Entrada de Datos</div>
            <div class="tab" data-tab="biseccion">Método de Bisección</div>
            <div class="tab" data-tab="newton">Método de Newton-Raphson</div>
            <div class="tab" data-tab="combinado">Método Combinado</div>
        </div>
        
        <div class="tab-content active" id="input-tab">
            <h2>Configuración de la Función</h2>
            
            <div class="input-section">
                <div class="input-group">
                    <label for="function">Función f(x):</label>
                    <input type="text" id="function" value="3*x**2 - 3*x + 2">
                    <small>Ejemplos: x^2 - 4, Math.sin(x), Math.exp(x) - 2</small>
                </div>
                
                <div class="input-group">
                    <label for="derivative">Derivada f'(x) (para Newton-Raphson):</label>
                    <input type="text" id="derivative" value="6*x - 3">
                    <small>Si se deja vacío, se calculará numéricamente</small>
                </div>
            </div>
            
            <h2>Parámetros de los Métodos</h2>
            
            <div class="input-section">
                <div class="input-group">
                    <label for="a">Extremo izquierdo (a):</label>
                    <input type="number" id="a" value="-3" step="any">
                </div>
                
                <div class="input-group">
                    <label for="b">Extremo derecho (b):</label>
                    <input type="number" id="b" value="3" step="any">
                </div>
                
                <div class="input-group">
                    <label for="tolerance">Tolerancia:</label>
                    <input type="number" id="tolerance" value="0.0001" step="any" min="0">
                </div>
                
                <div class="input-group">
                    <label for="maxIterations">Máximo de iteraciones:</label>
                    <input type="number" id="maxIterations" value="100" min="1">
                </div>
            </div>
            
            <div class="input-section">
                <div class="input-group">
                    <label for="initialGuess">Valor inicial (para Newton-Raphson):</label>
                    <input type="number" id="initialGuess" value="1" step="any">
                </div>
                
                <div class="input-group">
                    <label for="decimalPlaces">Número de cifras decimales:</label>
                    <input type="number" id="decimalPlaces" value="6" min="0" max="15">
                </div>
            </div>
            
            <button id="calculate">Calcular Raíces</button>
        </div>
        
        <div class="tab-content" id="biseccion-tab">
            <h2>Método de Bisección</h2>
            <div class="method-explanation">
                <p>El método de bisección es un algoritmo de búsqueda de raíces que funciona dividiendo repetidamente un intervalo a la mitad y luego seleccionando el subintervalo que contiene la raíz.</p>
            </div>
            <div id="biseccion-results"></div>
        </div>
        
        <div class="tab-content" id="newton-tab">
            <h2>Método de Newton-Raphson</h2>
            <div class="method-explanation">
                <p>El método de Newton-Raphson es un algoritmo iterativo para encontrar aproximaciones sucesivas a las raíces de una función real. Utiliza la derivada de la función para converger más rápidamente.</p>
            </div>
            <div id="newton-results"></div>
        </div>
        
        <div class="tab-content" id="combinado-tab">
            <h2>Método Combinado</h2>
            <div class="method-explanation">
                <p>Este método combina las ventajas de ambos métodos: usa bisección para garantizar convergencia cuando Newton-Raphson podría fallar, y Newton-Raphson para acelerar la convergencia cuando es aplicable.</p>
            </div>
            <div id="combinado-results"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Manejo de pestañas
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    // Remover clase active de todas las pestañas y contenidos
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    
                    // Agregar clase active a la pestaña clickeada
                    this.classList.add('active');
                    
                    // Mostrar el contenido correspondiente
                    const tabId = this.getAttribute('data-tab');
                    document.getElementById(`${tabId}-tab`).classList.add('active');
                });
            });
            
            // Botón de cálculo
            document.getElementById('calculate').addEventListener('click', calculateRoots);
            
            // Función para evaluar una expresión matemática
            function evaluateFunction(expression, x) {
                // Reemplazar 'x' con el valor numérico
                const expr = expression.replace(/x/g, `(${x})`);
                
                try {
                    // Usar Function constructor para evaluar la expresión
                    return Function(`"use strict"; return (${expr})`)();
                } catch (error) {
                    console.error("Error al evaluar la función:", error);
                    return NaN;
                }
            }
            
            // Calcular derivada numéricamente si no se proporciona
            function numericalDerivative(f, x, h = 1e-7) {
                return (evaluateFunction(f, x + h) - evaluateFunction(f, x - h)) / (2 * h);
            }
            
            // Método de Bisección
            function bisectionMethod(f, a, b, tolerance, maxIterations) {
                let fa = evaluateFunction(f, a);
                let fb = evaluateFunction(f, b);
                
                // Verificar si hay cambio de signo en el intervalo
                if (fa * fb > 0) {
                    return {
                        success: false,
                        message: "La función no cambia de signo en el intervalo [a, b]. No se puede aplicar el método de bisección.",
                        iterations: []
                    };
                }
                
                let iterations = [];
                let c, fc;
                
                for (let i = 0; i < maxIterations; i++) {
                    c = (a + b) / 2;
                    fc = evaluateFunction(f, c);
                    
                    iterations.push({
                        iteration: i + 1,
                        a: a,
                        b: b,
                        c: c,
                        f_c: fc,
                        error: Math.abs(b - a) / 2
                    });
                    
                    // Verificar si hemos encontrado la raíz
                    if (Math.abs(fc) < tolerance || Math.abs(b - a) / 2 < tolerance) {
                        return {
                            success: true,
                            root: c,
                            iterations: iterations
                        };
                    }
                    
                    // Determinar el siguiente intervalo
                    if (fa * fc < 0) {
                        b = c;
                        fb = fc;
                    } else {
                        a = c;
                        fa = fc;
                    }
                }
                
                return {
                    success: false,
                    message: "El método de bisección no convergió en el número máximo de iteraciones.",
                    iterations: iterations
                };
            }
            
            // Método de Newton-Raphson
            function newtonRaphsonMethod(f, df, x0, tolerance, maxIterations) {
                let iterations = [];
                let x = x0;
                let fx, dfx, error;
                
                for (let i = 0; i < maxIterations; i++) {
                    fx = evaluateFunction(f, x);
                    
                    // Calcular derivada
                    if (df) {
                        dfx = evaluateFunction(df, x);
                    } else {
                        dfx = numericalDerivative(f, x);
                    }
                    
                    // Verificar si la derivada es cero
                    if (Math.abs(dfx) < 1e-10) {
                        return {
                            success: false,
                            message: "La derivada es cero. No se puede aplicar el método de Newton-Raphson.",
                            iterations: iterations
                        };
                    }
                    
                    // Calcular siguiente aproximación
                    let xNew = x - fx / dfx;
                    error = Math.abs(xNew - x);
                    
                    iterations.push({
                        iteration: i + 1,
                        x: x,
                        f_x: fx,
                        df_x: dfx,
                        x_new: xNew,
                        error: error
                    });
                    
                    // Verificar convergencia
                    if (error < tolerance || Math.abs(fx) < tolerance) {
                        return {
                            success: true,
                            root: xNew,
                            iterations: iterations
                        };
                    }
                    
                    x = xNew;
                }
                
                return {
                    success: false,
                    message: "El método de Newton-Raphson no convergió en el número máximo de iteraciones.",
                    iterations: iterations
                };
            }
            
            // Método Combinado
            function combinedMethod(f, df, a, b, x0, tolerance, maxIterations) {
                let iterations = [];
                let x = x0;
                let fa = evaluateFunction(f, a);
                let fb = evaluateFunction(f, b);
                
                // Verificar si hay cambio de signo en el intervalo
                if (fa * fb > 0) {
                    return {
                        success: false,
                        message: "La función no cambia de signo en el intervalo [a, b]. No se puede aplicar el método combinado.",
                        iterations: []
                    };
                }
                
                let fx, dfx, error;
                
                for (let i = 0; i < maxIterations; i++) {
                    fx = evaluateFunction(f, x);
                    
                    // Calcular derivada
                    if (df) {
                        dfx = evaluateFunction(df, x);
                    } else {
                        dfx = numericalDerivative(f, x);
                    }
                    
                    // Verificar si la derivada es cero
                    if (Math.abs(dfx) < 1e-10) {
                        // Usar bisección si la derivada es cero
                        let c = (a + b) / 2;
                        let fc = evaluateFunction(f, c);
                        
                        iterations.push({
                            iteration: i + 1,
                            method: "Bisección",
                            a: a,
                            b: b,
                            x: c,
                            f_x: fc,
                            error: Math.abs(b - a) / 2
                        });
                        
                        // Determinar el siguiente intervalo
                        if (fa * fc < 0) {
                            b = c;
                            fb = fc;
                        } else {
                            a = c;
                            fa = fc;
                        }
                        
                        x = c;
                        error = Math.abs(b - a) / 2;
                    } else {
                        // Usar Newton-Raphson
                        let xNew = x - fx / dfx;
                        error = Math.abs(xNew - x);
                        
                        // Verificar si xNew está dentro del intervalo [a, b]
                        if (xNew < a || xNew > b) {
                            // Si no está, usar bisección
                            let c = (a + b) / 2;
                            let fc = evaluateFunction(f, c);
                            
                            iterations.push({
                                iteration: i + 1,
                                method: "Bisección (Newton fuera del intervalo)",
                                a: a,
                                b: b,
                                x: c,
                                f_x: fc,
                                error: Math.abs(b - a) / 2
                            });
                            
                            // Determinar el siguiente intervalo
                            if (fa * fc < 0) {
                                b = c;
                                fb = fc;
                            } else {
                                a = c;
                                fa = fc;
                            }
                            
                            x = c;
                        } else {
                            // Usar Newton-Raphson
                            iterations.push({
                                iteration: i + 1,
                                method: "Newton-Raphson",
                                x: x,
                                f_x: fx,
                                df_x: dfx,
                                x_new: xNew,
                                error: error
                            });
                            
                            x = xNew;
                        }
                    }
                    
                    // Verificar convergencia
                    if (error < tolerance || Math.abs(fx) < tolerance) {
                        return {
                            success: true,
                            root: x,
                            iterations: iterations
                        };
                    }
                }
                
                return {
                    success: false,
                    message: "El método combinado no convergió en el número máximo de iteraciones.",
                    iterations: iterations
                };
            }
            
            // Función principal para calcular raíces
            function calculateRoots() {
                // Obtener parámetros de entrada
                const f = document.getElementById('function').value;
                const df = document.getElementById('derivative').value || null;
                const a = parseFloat(document.getElementById('a').value);
                const b = parseFloat(document.getElementById('b').value);
                const tolerance = parseFloat(document.getElementById('tolerance').value);
                const maxIterations = parseInt(document.getElementById('maxIterations').value);
                const x0 = parseFloat(document.getElementById('initialGuess').value);
                const decimalPlaces = parseInt(document.getElementById('decimalPlaces').value);
                
                // Validar entrada
                if (a >= b) {
                    alert("El valor de 'a' debe ser menor que 'b'.");
                    return;
                }
                
                if (tolerance <= 0) {
                    alert("La tolerancia debe ser un número positivo.");
                    return;
                }
                
                // Aplicar métodos
                const bisectionResult = bisectionMethod(f, a, b, tolerance, maxIterations);
                const newtonResult = newtonRaphsonMethod(f, df, x0, tolerance, maxIterations);
                const combinedResult = combinedMethod(f, df, a, b, x0, tolerance, maxIterations);
                
                // Mostrar resultados
                displayResults(bisectionResult, 'biseccion-results', 'Bisección', decimalPlaces);
                displayResults(newtonResult, 'newton-results', 'Newton-Raphson', decimalPlaces);
                displayResults(combinedResult, 'combinado-results', 'Combinado', decimalPlaces);
            }
            
            // Función para mostrar resultados en formato de tabla
            function displayResults(result, elementId, methodName, decimalPlaces) {
                const container = document.getElementById(elementId);
                container.innerHTML = '';
                
                if (!result.success) {
                    container.innerHTML = `<div class="error">${result.message}</div>`;
                    return;
                }
                
                // Mostrar la raíz encontrada
                container.innerHTML += `
                    <div class="success">
                        Raíz encontrada: ${result.root.toFixed(decimalPlaces)}
                    </div>
                `;
                
                // Crear tabla de iteraciones
                if (result.iterations.length > 0) {
                    let tableHTML = `
                        <table>
                            <thead>
                                <tr>
                    `;
                    
                    // Encabezados de la tabla según el método
                    const headers = Object.keys(result.iterations[0]);
                    headers.forEach(header => {
                        tableHTML += `<th>${header}</th>`;
                    });
                    
                    tableHTML += `
                                </tr>
                            </thead>
                            <tbody>
                    `;
                    
                    // Filas de la tabla
                    result.iterations.forEach(iteration => {
                        tableHTML += `<tr>`;
                        headers.forEach(header => {
                            let value = iteration[header];
                            if (typeof value === 'number') {
                                value = value.toFixed(decimalPlaces);
                            }
                            tableHTML += `<td>${value}</td>`;
                        });
                        tableHTML += `</tr>`;
                    });
                    
                    tableHTML += `
                            </tbody>
                        </table>
                    `;
                    
                    container.innerHTML += tableHTML;
                }
            }
        });
    </script>
</body>
</html>